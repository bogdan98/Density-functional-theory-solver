module DFTSolver
use hartree
use correction
use excorr
use ode
use int_interp
use parameters
implicit none
contains

  subroutine iterates(ns, ls, number, density, vext, r, rab, nr, u, ud, a, b,  &
    & rmax, energies, Et, Z, ec, enuc, ex, iterations)
    !takes two integer arrays, of length 'number', one with numbers corresponding
    !to energy levels (n), the other one - to angular momentum (l). Trial density,
    !radial grid and external potential are at the input as well. The subroutine
    !calculates eigenenergies, total energy, Coulomb, excorr and nuclear energy,
    !as well as the self-consistent charge density
    integer nr, i, lp, l, ls(number), ns(number), number, nlps, iterations;
    real(kind = kind(1.d0)) density(nr), d2(nr), r(nr), rab(nr), u(nr), &
    &ud(nr), a, b, rmax, el1(number), vext(nr), v2(nr), Et, corrE, ediff, ein,&
    &deltaE(nr), ang(nr), energies(:), Z, ec, enuc, ex;
    Et = 0.d0;
    iterations = 0;
    corrE = 0.d0;
    ein = 0.d0;
    ediff = 100.d0;
    ec = 0.d0;
    enuc = 0.d0;
    ex = 0.d0;
    d2 = density;
    do while(ediff > 1.0E-8) !iterate untill self-consistency is reached
      iterations = iterations + 1;
      density = d2;
      v2 = vext;
      call VHartree(density, r, rab, nr, v2); !hartree potential calculation
      call vxc(density, nr, v2); !exchange-correlation potential calculation
      density = 0.d0;
      Et = 0.d0;
      do lp = 1, number
        u=0.d0 ; ud=0.d0 ; l=ls(lp) ; energies(lp)= -10.0d0 !starting guess for eigenenergies, can be altered;
        ang(:) = 0.5d0*dble(l*(l+1))/r(:)**2
        call difnrl(lp,v2(:)+ang(:),              & !solve for orbitals to get the density generated by potential
         &         0.d0,u,ud,nr,a,b,r,rab,number,ns,ls,Z,                 &
         &         rmax,energies);
         density(2:nr) = density(2:nr) + (u(2:nr)/r(2:nr))**2;
         density(1) = density(2);
         Et = Et + energies(lp);
       end do
       d2 = 0.5d0*density + d2*0.5d0; !linear mixing to get the starting density for the next iteration
      ediff = abs(Et - ein); !difference in total energy, to monitor self-consistency
      ein = Et;
    end do
    call totalcorr(density, r, rab, nr, corrE, deltaE, Z, ec, enuc, ex);
    Et = Et + corrE; !corrected total energy, with the account for hartree and excorr energies
  end subroutine

end module DFTSolver
